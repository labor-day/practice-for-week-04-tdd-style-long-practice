// Your code here
const chai = require("chai");
const expect = chai.expect;
const spies = require("chai-spies");
chai.use(spies);

const Person = require("../problems/person")

describe("Person class", function() {

  let person;
  let visitor = new Person("bob", 20);
  let otherPerson = new Person("rob", 30);
  let updater = { name: "lulu", age: 57 };
  let onlyAge = { age: 57 };
  let onlyName = { name: "janet" };

  beforeEach( () => {
    person = new Person("sesame", 10);
  });

  describe("Person constructor function", function() {
    it("should create a name and age property", function() {
      expect(person).to.have.property("name");
      expect(person).to.have.property("age");
    });
    it("should properly set the name and age properties", function() {
      expect(person.name).to.equal("sesame");
      expect(person.age).to.equal(10);
    });
  });

  describe("sayHello function", function() {
    it ("should return the correct greeting message", function() {
      expect(person.sayHello()).to.equal(`Hello, my name is ${person.name}.`);
    });
  });

  describe("visit function", function() {
    it ("should return the correct visitation string", function() {
       expect(visitor.visit(person)).to.equal(`${visitor.name} visited ${person.name}`);
    });
  });

  describe("switch visit function", function() {
     it("should invoke the visit function of the argument", function() {
      let spy = chai.spy.on(person, "visit");
      expect(visitor.switchVisit(person)).to.equal(`${person.name} visited ${visitor.name}`);
      expect(spy).to.have.been.called(1);
     });
  });

  describe("update function", function() {
    context("if the incoming argument is not an object", function() {
      it("should throw a Type Error with a clear message", function() {
        expect( () => person.update(5) ).throw(TypeError);
        expect( () => person.update(5) ).throw("input is not an object");
      });
    });

    context("if the incoming object does not have a name and age property", function() {
      it("should throw a Type Error with a clear message", function() {
        expect( () => person.update(onlyAge)).to.throw(TypeError);
        expect( () => person.update(onlyAge)).to.throw("input does not have name property");

        expect( () => person.update(onlyName)).to.throw(TypeError);
        expect( () => person.update(onlyName)).to.throw("input does not have age property");
      });
    });

    context("if the incoming argument is acceptable", function() {
      it("should update the instance's properties to those of the passed in object", function() {
        person.update(updater);
        expect(person.age).to.equal(57);
        expect(person.name).to.equal("lulu");
      });
    });
  });

  describe("tryUpdate function", function() {
    context("if tryUpdate was successfully invoked", function() {
      it("should return true", function() {
        expect(person.tryUpdate(updater)).to.equal(true);
      });

      it("should update the instances properties to those of the passed in object", function() {
        person.tryUpdate(updater);
        expect(person.age).to.equal(57);
        expect(person.name).to.equal("lulu");
      });
    });

    context("if tryUpdate was not succesfully invoked", function() {
      it("should return false", function() {
        expect(person.tryUpdate(onlyName)).to.equal(false);
      });
      it("should not throw an error", function() {
        expect( () => person.tryUpdate(onlyAge) ).to.not.throw(TypeError);
      });
    });
  });

  describe("greetAll function", function() {
    it("should return an array of strings generated by sayHello()", function() {
      expect(person.greetAll([visitor, otherPerson])).to.deep.equal([visitor.sayHello(), otherPerson.sayHello()]);
    });
    it("should call sayHello() on each person in the input array", function() {
      let spy1 = chai.spy.on(visitor, "sayHello");
      let spy2 = chai.spy.on(otherPerson, "sayHello");
      person.greetAll([visitor, otherPerson]);
      expect(spy1).to.have.been.called(1);
      expect(spy2).to.have.been.called(1);
    })
  })

});
